<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LuckyDraw Control Panel</title>
    <link rel="stylesheet" href="/admin/assets/css/cs-skin-elastic.css">
    <link rel="stylesheet" href="/admin/assets/css/lib/datatable/dataTables.bootstrap.min.css">
    <link rel="stylesheet" href="/admin/assets/css/style.css">

    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .control-panel-container {
            padding: 20px;
        }
        .control-card {
            border-radius: 8px;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 12px;
        }
        .form-group label {
            font-weight: 600;
        }
        .winner-list {
            max-height: 350px;
            overflow-y: auto;
            padding: 0;
            margin: 0;
            list-style: none;
        }
        .winner-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        .winner-main {
            display: flex;
            flex-direction: column;
        }
        .winner-name {
            font-weight: 600;
        }
        .winner-meta {
            font-size: 12px;
            color: #666;
        }
        .connection-toast {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 2000;
            padding: 8px 14px;
            border-radius: 4px;
            font-size: 13px;
            color: #fff;
            background-color: rgba(220, 53, 69, 0.9); /* default danger */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out;
        }
        .connection-toast.show {
            opacity: 1;
        }
        .connection-toast.success {
            background-color: rgba(40, 167, 69, 0.9);
        }
        .connection-toast.warning {
            background-color: rgba(255, 193, 7, 0.9);
        }
        @media (max-width: 992px) {
            .control-panel-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<%- include("components/header") %>
<%- include("components/menu", { eventId: eventId }) %>

<div id="right-panel" class="right-panel">
    <%- include("components/rightpanel_header") %>

    <div class="content">
        <div class="animated fadeIn">
            <div class="row control-panel-container">
                <div class="col-lg-7 col-md-12 mb-3">
                    <div class="card control-card">
                        <div class="section-title">Draw Control (iPad-friendly)</div>
                        <div class="form-group">
                            <label for="prizeSelect">Select prize:</label>
                            <div class="mb-2" id="prizeImageContainer" style="display:none; text-align:center;">
                                <img id="prizeImage" src="" alt="Select prize" style="max-width: 200px; max-height: 150px; border-radius: 8px; border: 2px solid #eee;">
                            </div>
                            <select id="prizeSelect" class="form-control" required>
                                <option value="">Please select a prize</option>
                                <% prizes.forEach(prize => { %>
                                    <% if (prize.unit > 0) { %>
                                        <option value="<%= prize._id %>" data-name="<%= prize.name %>" data-image="<%= prize.pictureUrl || prize.picture || '' %>">
                                            <%= prize.name %> (remaining: <%= prize.unit %>)
                                        </option>
                                    <% } %>
                                <% }); %>
                            </select>
                        </div>

                        <div class="form-row">
                            <div class="form-group col-md-4">
                                <label for="drawCount">Draw count:</label>
                                <input type="number" id="drawCount" class="form-control" min="1" value="1">
                            </div>
                        </div>

                        <div class="form-group mt-3">
                            <button id="btn-draw-once" class="btn btn-primary btn-block mb-2">Draw 1</button>
                            <button id="btn-draw-multi" class="btn btn-success btn-block mb-2">Draw (by count above)</button>
                            <button id="btn-cancel-last" class="btn btn-warning btn-block mb-2">Cancel Last Winner</button>
                        </div>

                        <hr>

                        <div class="section-title">Manual Winner</div>
                        <div class="form-group">
                            <label for="manualWinnerSelect">Select participant:</label>
                            <select id="manualWinnerSelect" class="form-control">
                                <option value="">Please select a participant</option>
                                <% availablePeople.forEach(person => { %>
                                    <option value="<%= person._id %>">
                                        <%= person.company || '' %>
                                        <% if (person.table) { %> | Table: <%= person.table %> <% } %>
                                        | <%= person.name %>
                                    </option>
                                <% }); %>
                            </select>
                        </div>
                        <button id="btn-set-manual-winner" class="btn btn-info btn-block">Set as Winner</button>
                    </div>
                </div>

                <div class="col-lg-5 col-md-12 mb-3">
                    <div class="card control-card">
                        <div class="section-title">Session Winners</div>
                        <ul id="winnerList" class="winner-list"></ul>
                        <small class="text-muted d-block mt-2">
                            This list shows winners from this panel session only. See "Luckydraw List" for full records.
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="controllerToast" class="connection-toast"></div>
<%- include("components/footer") %>

<script src="/socket.io/socket.io.js"></script>
<script>
    const allPeople = <%- JSON.stringify(availablePeople) %>;
    const allPrizes = <%- JSON.stringify(prizes) %>; // ‰øùÂ≠òÊâÄÊúâÁçéÂìÅÊï∏Êìö
    const eventId = '<%= eventId %>';

    let availablePeople = [...allPeople];
    const sessionWinners = [];

    const prizeSelect = document.getElementById('prizeSelect');
    const prizeImage = document.getElementById('prizeImage');
    const prizeImageContainer = document.getElementById('prizeImageContainer');
    const drawCountInput = document.getElementById('drawCount');
    const winnerList = document.getElementById('winnerList');
    const manualWinnerSelect = document.getElementById('manualWinnerSelect');

    // ÂàùÂßãÂåñ Socket.IO ‰∏¶Âä†ÂÖ• luckydraw room
    const socket = io();
    socket.emit('join_luckydraw', { eventId, type: 'panel' });

    const controllerToast = document.getElementById('controllerToast');
    let toastTimer = null;

    function showControllerToast(message, type) {
        controllerToast.textContent = message;
        controllerToast.classList.remove('success', 'warning');
        if (type === 'success') controllerToast.classList.add('success');
        if (type === 'warning') controllerToast.classList.add('warning');
        controllerToast.classList.add('show');
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
            controllerToast.classList.remove('show');
        }, 2000);
    }

    function updatePrizePreview() {
        const selectedOption = prizeSelect.options[prizeSelect.selectedIndex];
        if (!selectedOption || !selectedOption.value) {
            prizeImageContainer.style.display = 'none';
            return;
        }
        const imagePath = selectedOption.dataset.image;
        if (imagePath && imagePath.trim() !== '') {
            prizeImage.src = imagePath;
            prizeImageContainer.style.display = 'block';
        } else {
            prizeImageContainer.style.display = 'none';
        }
    }

    function sendPrizeSelection() {
        const selectedOption = prizeSelect.options[prizeSelect.selectedIndex];
        if (selectedOption && selectedOption.value) {
            const prizeName = selectedOption.dataset.name || selectedOption.text.split('(')[0].trim();
            const prizeImage = selectedOption.dataset.image || '';
            socket.emit('luckydraw_panel_prize_selected', { 
                eventId, 
                prizeName: prizeName,
                prizeImage: prizeImage
            });
        } else {
            // Ê∏ÖÈô§ÁçéÂìÅÈÅ∏Êìá
            socket.emit('luckydraw_panel_prize_selected', { 
                eventId, 
                prizeName: null,
                prizeImage: null
            });
        }
    }

    prizeSelect.addEventListener('change', () => {
        updatePrizePreview();
        sendPrizeSelection();
    });
    
    document.addEventListener('DOMContentLoaded', () => {
        updatePrizePreview();
        // È†ÅÈù¢ËºâÂÖ•ÂæåÔºåÂ¶ÇÊûúÊúâÂ∑≤ÈÅ∏ÊìáÁöÑÁçéÂìÅÔºåÁôºÈÄÅÈÅ∏Êìá‰∫ã‰ª∂
        setTimeout(sendPrizeSelection, 500);
    });

    async function cancelWinner(winner) {
        if (!confirm(`Are you sure you want to cancel the win for ${winner.name}?`)) {
            return;
        }
        try {
            const res = await fetch(`/events/${eventId}/luckydraw`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ _id: winner._id })
            });
            if (!res.ok) {
                const msg = await res.text();
                alert('Failed to cancel winner: ' + msg);
                return;
            }
            // Âæû sessionWinners ‰∏≠ÁßªÈô§
            const index = sessionWinners.findIndex(w => String(w._id) === String(winner._id));
            if (index !== -1) {
                sessionWinners.splice(index, 1);
                renderWinnerList();
            }

            // ÈÇÑÂéüÁçéÂìÅÊï∏Èáè
            if (winner.prizeId) {
                const option = Array.from(prizeSelect.options).find(o => o.value === winner.prizeId);
                if (option) {
                    const text = option.text;
                    const match = text.match(/\(remaining: (\d+)\)/);
                    const currentRemaining = match ? parseInt(match[1]) : 0;
                    updatePrizeOptionText(option, currentRemaining + 1);
                } else {
                    // ÈÅ∏È†Ö‰∏çÂ≠òÂú®ÔºàÂõ†ÁÇ∫Êï∏ÈáèÁÇ∫0ÊôÇË¢´ÁßªÈô§‰∫ÜÔºâÔºåÈúÄË¶ÅÈáçÊñ∞ÂâµÂª∫
                    const prize = allPrizes.find(p => String(p._id) === String(winner.prizeId));
                    const newOption = document.createElement('option');
                    newOption.value = winner.prizeId;
                    newOption.dataset.name = winner.prizeName || prize?.name || 'Unknown prize';
                    newOption.dataset.image = prize?.pictureUrl || prize?.picture || '';
                    newOption.text = `${winner.prizeName || prize?.name || 'Unknown prize'} (remaining: 1)`;
                    if (prizeSelect.options.length > 1) {
                        prizeSelect.insertBefore(newOption, prizeSelect.options[1]);
                    } else {
                        prizeSelect.appendChild(newOption);
                    }
                }
            }

            // ÈÇÑÂéüÂèÉËàáËÄÖÂà∞ÂèØÁî®ÂàóË°®
            availablePeople.push({
                _id: winner._id,
                name: winner.name,
                company: winner.company,
                table: winner.table
            });
            
            // Êõ¥Êñ∞ÊâãÂãïÈÅ∏Êìá‰∏ãÊãâÂàóË°®
            const manualOption = document.createElement('option');
            manualOption.value = winner._id;
            manualOption.text = `${winner.company || ''} ${winner.table ? ' | Table: ' + winner.table : ''} | ${winner.name}`;
            manualWinnerSelect.appendChild(manualOption);
        } catch (err) {
            console.error(err);
            alert('Error cancelling winner');
        }
    }

    function renderWinnerList() {
        winnerList.innerHTML = '';
        sessionWinners.forEach((w) => {
            const li = document.createElement('li');
            li.className = 'winner-item';
            li.dataset.id = w._id;
            li.style.cursor = 'pointer';
            li.style.userSelect = 'none';
            li.title = 'Click to cancel this winner';
            // ‰ΩøÁî®‰∏≠ÁçéÁ∑®ËôüÔºàorderÔºâÂèñ‰ª£Â∫èËôü
            const orderNumber = w.order || '';
            li.innerHTML = `
                <div class="winner-main">
                    <span class="winner-name">${orderNumber ? orderNumber + '. ' : ''}${w.name}</span>
                    <span class="winner-meta">
                        ${w.company || ''} ${w.table ? ' | Table: ' + w.table : ''} ${w.prizeName ? ' | üéÅ ' + w.prizeName : ''}
                    </span>
                </div>
            `;
            // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂
            li.addEventListener('click', () => {
                cancelWinner(w);
            });
            // Ê∑ªÂä†ÊÇ¨ÂÅúÊïàÊûú
            li.addEventListener('mouseenter', () => {
                li.style.backgroundColor = '#f8f9fa';
            });
            li.addEventListener('mouseleave', () => {
                li.style.backgroundColor = '';
            });
            winnerList.appendChild(li);
        });
    }

    // ÈÄ£Á∑öÁãÄÊÖãÊèêÁ§∫ÔºàÊéßÂà∂Âô®Êú¨Ë∫´Ôºâ
    socket.on('connect', () => {
        showControllerToast('Controller connected to server', 'success');
    });

    socket.on('disconnect', () => {
        showControllerToast('Controller disconnected. Please check network.', 'warning');
    });

    // ‰æÜËá™‰º∫ÊúçÂô®ÁöÑÊéßÂà∂Âô®ÁãÄÊÖãÂª£Êí≠ÔºàÂêå‰∏Ä event ÁöÑÊâÄÊúâÈ†ÅÈù¢ÈÉΩÊúÉÊî∂Âà∞Ôºâ
    socket.on('luckydraw:controller_status', ({ status }) => {
        if (status === 'online') {
            showControllerToast('Controller ready. You can start drawing.', 'success');
        } else if (status === 'offline') {
            showControllerToast('Controller not connected', 'warning');
        }
    });

    function pickRandomPerson() {
        if (availablePeople.length === 0) {
            alert('Everyone has been drawn!');
            return null;
        }
        const idx = Math.floor(Math.random() * availablePeople.length);
        return availablePeople.splice(idx, 1)[0];
    }

    function getSelectedPrize() {
        if (!prizeSelect.value) {
            alert('Please select a prize first!');
            return null;
        }
        const option = prizeSelect.options[prizeSelect.selectedIndex];
        const text = option.text;
        const match = text.match(/\(remaining: (\d+)\)/);
        if (!match) {
            alert('Unable to get prize stock info!');
            return null;
        }
        const remaining = parseInt(match[1]);
        if (remaining <= 0) {
            alert('Selected prize is out of stock!');
            return null;
        }
        return {
            prizeId: option.value,
            prizeName: option.dataset.name || '',
            remaining,
            option
        };
    }

    function updatePrizeOptionText(option, newRemaining) {
        if (newRemaining <= 0) {
            option.remove();
            if (prizeSelect.options.length > 0) {
                prizeSelect.selectedIndex = 0;
            }
        } else {
            option.text = option.text.replace(/\(remaining: \d+\)/, `(remaining: ${newRemaining})`);
        }
    }

    async function confirmWinner(person) {
        const prizeInfo = getSelectedPrize();
        if (!prizeInfo) return;

        const payload = {
            _id: person._id,
            name: person.name,
            company: person.company,
            table: person.table,
            prizeId: prizeInfo.prizeId
        };

        try {
            const res = await fetch(`/events/${eventId}/luckydraw`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!res.ok) {
                const msg = await res.text();
                alert('Failed to add winner: ' + msg);
                return;
            }
            const data = await res.json();
            const winner = {
                ...data.winner,
                prizeName: prizeInfo.prizeName
            };
            sessionWinners.push(winner);
            renderWinnerList();

            const newRemaining = prizeInfo.remaining - 1;
            updatePrizeOptionText(prizeInfo.option, newRemaining);
        } catch (err) {
            console.error(err);
            alert('Error adding winner');
        }
    }

    document.getElementById('btn-draw-once').addEventListener('click', async () => {
        // ÈÄöÁü•Â±ïÁ§∫È†ÅÈñãÂßãÂãïÁï´
        socket.emit('luckydraw_panel_start', { eventId });
        const person = pickRandomPerson();
        if (!person) return;
        await confirmWinner(person);
    });

    document.getElementById('btn-draw-multi').addEventListener('click', async () => {
        const prizeInfo = getSelectedPrize();
        if (!prizeInfo) return;
        
        const count = Math.max(1, parseInt(drawCountInput.value || '1', 10));
        
        if (prizeInfo.remaining <= 0) {
            alert('Prize is out of stock. Cannot draw.');
            return;
        }

        if (count > prizeInfo.remaining) {
            alert(`Insufficient prize stock. You can only draw ${prizeInfo.remaining} at most.`);
            return;
        }

        if (availablePeople.length < count) {
            alert(`Not enough participants. Only ${availablePeople.length} available.`);
            return;
        }

        // ÈÄöÁü•Â±ïÁ§∫È†ÅÈñãÂßãÂãïÁï´ÔºàÂè™ÈÄöÁü•‰∏ÄÊ¨°Ôºâ
        socket.emit('luckydraw_panel_start', { eventId });

        try {
            // ‰ΩøÁî®ÊâπÈáèÊäΩÁçé API
            const res = await fetch(`/events/${eventId}/luckydraw/batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    count: count,
                    prizeId: prizeInfo.prizeId
                })
            });

            if (!res.ok) {
                const msg = await res.text();
                alert('Batch draw failed: ' + msg);
                return;
            }

            const data = await res.json();
            
            // Êõ¥Êñ∞ÂèØÁî®‰∫∫Âì°ÂàóË°®ÔºàÁßªÈô§Â∑≤‰∏≠ÁçéÁöÑ‰∫∫Ôºâ
            if (data.winners && Array.isArray(data.winners)) {
                data.winners.forEach(winner => {
                    const index = availablePeople.findIndex(p => String(p._id) === String(winner._id));
                    if (index !== -1) {
                        availablePeople.splice(index, 1);
                    }
                    sessionWinners.push({
                        ...winner,
                        prizeName: prizeInfo.prizeName
                    });
                });
            }

            renderWinnerList();

            // Êõ¥Êñ∞ÁçéÂìÅÈÅ∏È†ÖÊñáÂ≠ó
            const newRemaining = prizeInfo.remaining - data.actualCount;
            updatePrizeOptionText(prizeInfo.option, newRemaining);

            // Socket ‰∫ã‰ª∂Â∑≤Á∂ìÁî±ÂæåÁ´Ø API ÁôºÈÄÅÔºåÈÄôË£°‰∏çÈúÄË¶ÅÂÜçÁôºÈÄÅ
            // ÂæåÁ´ØÊúÉËá™ÂãïÁôºÈÄÅ luckydraw:winner_added ‰∫ã‰ª∂Áµ¶ÊâÄÊúâÈÄ£Êé•ÁöÑÂÆ¢Êà∂Á´Ø
        } catch (err) {
            console.error(err);
            alert('Error during batch draw: ' + err.message);
        }
    });

    document.getElementById('btn-cancel-last').addEventListener('click', async () => {
        if (sessionWinners.length === 0) {
            alert('There is no winner to cancel.');
            return;
        }
        const lastWinner = sessionWinners[sessionWinners.length - 1];
        if (!confirm(`Are you sure you want to cancel the win for ${lastWinner.name}?`)) {
            return;
        }
        try {
            const res = await fetch(`/events/${eventId}/luckydraw`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ _id: lastWinner._id })
            });
            if (!res.ok) {
                const msg = await res.text();
                alert('Failed to cancel winner: ' + msg);
                return;
            }
            sessionWinners.pop();
            renderWinnerList();

            // ÈÇÑÂéüÁçéÂìÅÊï∏Èáè
            if (lastWinner.prizeId) {
                const option = Array.from(prizeSelect.options).find(o => o.value === lastWinner.prizeId);
                if (option) {
                    const text = option.text;
                    const match = text.match(/\(remaining: (\d+)\)/);
                    const currentRemaining = match ? parseInt(match[1]) : 0;
                    updatePrizeOptionText(option, currentRemaining + 1);
                } else {
                    // ÈÅ∏È†Ö‰∏çÂ≠òÂú®ÔºàÂõ†ÁÇ∫Êï∏ÈáèÁÇ∫0ÊôÇË¢´ÁßªÈô§‰∫ÜÔºâÔºåÈúÄË¶ÅÈáçÊñ∞ÂâµÂª∫
                    const prize = allPrizes.find(p => String(p._id) === String(lastWinner.prizeId));
                    const newOption = document.createElement('option');
                    newOption.value = lastWinner.prizeId;
                    newOption.dataset.name = lastWinner.prizeName || prize?.name || 'Unknown prize';
                    newOption.dataset.image = prize?.pictureUrl || prize?.picture || '';
                    newOption.text = `${lastWinner.prizeName || prize?.name || 'Unknown prize'} (remaining: 1)`;
                    if (prizeSelect.options.length > 1) {
                        prizeSelect.insertBefore(newOption, prizeSelect.options[1]);
                    } else {
                        prizeSelect.appendChild(newOption);
                    }
                }
            }

            availablePeople.push({
                _id: lastWinner._id,
                name: lastWinner.name,
                company: lastWinner.company,
                table: lastWinner.table
            });
        } catch (err) {
            console.error(err);
            alert('Error cancelling winner');
        }
    });

    document.getElementById('btn-set-manual-winner').addEventListener('click', async () => {
        const selectedId = manualWinnerSelect.value;
        if (!selectedId) {
            alert('Please select a participant first');
            return;
        }
        const index = availablePeople.findIndex(p => String(p._id) === String(selectedId));
        if (index === -1) {
            alert('Selected participant not found. They may have already won or are not on the list.');
            return;
        }
        // ÈÄöÁü•Â±ïÁ§∫È†ÅÈñãÂßãÂãïÁï´
        socket.emit('luckydraw_panel_start', { eventId });
        const person = availablePeople.splice(index, 1)[0];
        await confirmWinner(person);
        manualWinnerSelect.value = '';
    });
</script>

</body>
</html>


